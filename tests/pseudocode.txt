// ---------------------------------------------------------
// SUPER-SIMPLE TIMING PSEUDOCODE (matches your style)
// Goal: every "tick" do EITHER input OR fall (not both)
// ---------------------------------------------------------

// ---- globals ----
unsigned long lastTick = 0;
const unsigned long tickMs = 400;   // game speed

bool inputQueued = false;           // did player press something since last tick?
// (you can store which input later; for now just "some input happened")

void loop() {

  // 1) Always read controls fast (every loop) and remember it for next tick
  //    IMPORTANT: do NOT move piece here, only queue the intent
  if_UserInput();                   // inside: if button/joystick pressed -> inputQueued = true

  // 2) Only run game logic when a tick happens
  if (millis() - lastTick < tickMs) return;
  lastTick += tickMs;               // stable tick timing

  // 3) Tick: do either INPUT or FALL
  if (inputQueued) {
    action_ExecuteUserAction();     // move left/right/rotate/down (one action)
    inputQueued = false;            // consume it so next tick can fall
  } else {
    action_MoveShapeDown();         // gravity (fall 1 cell)
  }

  // 4) Resolve collisions AFTER the move attempt
  if_VerticalCollision();           // checks if piece is blocked / landed
  if (if_VerticalCollision()) {
    action_LockPiece();             // fix piece into grid
  }

  // 5) Clear rows if needed
  if_RowFilled();
  if (if_RowFilled()) {
    action_DeleteRow();
  }

  // 6) Lose check
  if_GameLost();
  if (if_GameLost()) {
    action_game_lost();
    action_Start();
    action_DefineBackgroundAndShapes();
  }

  // 7) Draw once per tick (keeps visuals synced)
  action_UpdateGrid();              // draws virtual->LED (and LCD if you want)
}
