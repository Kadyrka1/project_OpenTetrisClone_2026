//-----------------------------------------------------------------------------------------------
//------LIBRARIES----------

#include <utility> //necessary for use of pairs
#include <FastLED.h>
#include <ctype.h>

// ---------------- LED CONFIG ----------------
#define LED_PIN       23
#define NUM_LEDS      100
#define BRIGHTNESS    80
#define LED_TYPE      WS2812B
#define COLOR_ORDER   GRB

CRGB leds[NUM_LEDS];

// ---------------- 9 COLORS ----------------
const CRGB COLORS[9] = {
  CRGB(255,0,0),
  CRGB(0,255,0),
  CRGB(0,0,255),
  CRGB(255,255,0),
  CRGB(255,0,255),
  CRGB(0,255,255),
  CRGB(255,255,255),
  CRGB(255,128,0),
  CRGB(0,0,0)
};

int piece_colour = 0;


// Tetriminos
#define PIECE_W 4
#define PIECE_H 4
#define PIECE_SIZE PIECE_W*PIECE_H
#define DIFF_PIECES 7

//Data for current part
int piece_id;
int piece_rotation;
int piece_x;
int piece_y;

// =====================================================
//             VIRTUAL + REAL MATRIX DIMENSIONS
// =====================================================

// "Virtual" matrix (game logic grid)
const int VIRTUAL_W = 16;
const int VIRTUAL_H = 16;

// Real grid size (LED physical)
static const int W = 10;
static const int H = 10;
// Crop settings: remove 3 from each side of 16x16 -> 10x10
static const int CROP = 3;

//virtual grid and others with colour and status  
using Cell = std::pair<uint8_t, uint8_t>; // {colorIndex, status}

Cell virt_grid[VIRTUAL_W][VIRTUAL_H];
Cell virt_entity[VIRTUAL_W][VIRTUAL_H];
Cell virt_entity_prev[VIRTUAL_W][VIRTUAL_H];
Cell virt_overlap[VIRTUAL_W][VIRTUAL_H];

// =====================================================
//                   SHAPES (16x4 each)
// =====================================================

const byte empty[] = {0};

const byte piece_I[] = {
  0, 0, 0, 0,
  1, 1, 1, 1,
  0, 0, 0, 0,
  0, 0, 0, 0,

  0, 1, 0, 0,
  0, 1, 0, 0,
  0, 1, 0, 0,
  0, 1, 0, 0,

  0, 0, 0, 0,
  1, 1, 1, 1,
  0, 0, 0, 0,
  0, 0, 0, 0,

  0, 1, 0, 0,
  0, 1, 0, 0,
  0, 1, 0, 0,
  0, 1, 0, 0,
};

const byte piece_T[] = {
  1, 1, 1, 0,
  0, 1, 0, 0,
  0, 0, 0, 0,
  0, 0, 0, 0,

  0, 1, 0, 0,
  1, 1, 0, 0,
  0, 1, 0, 0,
  0, 0, 0, 0,

  0, 1, 0, 0,
  1, 1, 1, 0,
  0, 0, 0, 0,
  0, 0, 0, 0,

  0, 1, 0, 0,
  0, 1, 1, 0,
  0, 1, 0, 0,
  0, 0, 0, 0,
};

const byte piece_L[] = {
  0, 0, 0, 0,
  1, 1, 1, 0,
  1, 0, 0, 0,
  0, 0, 0, 0,

  1, 1, 0, 0,
  0, 1, 0, 0,
  0, 1, 0, 0,
  0, 0, 0, 0,

  0, 0, 1, 0,
  1, 1, 1, 0,
  0, 0, 0, 0,
  0, 0, 0, 0,

  0, 1, 0, 0,
  0, 1, 0, 0,
  0, 1, 1, 0,
  0, 0, 0, 0,
};

const byte piece_J[] = {
  1, 0, 0, 0,
  1, 1, 1, 0,
  0, 0, 0, 0,
  0, 0, 0, 0,

  0, 1, 1, 0,
  0, 1, 0, 0,
  0, 1, 0, 0,
  0, 0, 0, 0,

  0, 0, 0, 0,
  1, 1, 1, 0,
  0, 0, 1, 0,
  0, 0, 0, 0,

  0, 1, 0, 0,
  0, 1, 0, 0,
  1, 1, 0, 0,
  0, 0, 0, 0,
};

const byte piece_S[] = {
  0, 1, 1, 0,
  1, 1, 0, 0,
  0, 0, 0, 0,
  0, 0, 0, 0,

  0, 1, 0, 0,
  0, 1, 1, 0,
  0, 0, 1, 0,
  0, 0, 0, 0,

  0, 1, 1, 0,
  1, 1, 0, 0,
  0, 0, 0, 0,
  0, 0, 0, 0,

  0, 1, 0, 0,
  0, 1, 1, 0,
  0, 0, 1, 0,
  0, 0, 0, 0,
};

const byte piece_Z[] = {
  1, 1, 0, 0,
  0, 1, 1, 0,
  0, 0, 0, 0,
  0, 0, 0, 0,

  0, 0, 1, 0,
  0, 1, 1, 0,
  0, 1, 0, 0,
  0, 0, 0, 0,

  1, 1, 0, 0,
  0, 1, 1, 0,
  0, 0, 0, 0,
  0, 0, 0, 0,

  0, 0, 1, 0,
  0, 1, 1, 0,
  0, 1, 0, 0,
  0, 0, 0, 0,
};

const byte piece_O[] = {
  1, 1, 0, 0,
  1, 1, 0, 0,
  0, 0, 0, 0,
  0, 0, 0, 0,

  1, 1, 0, 0,
  1, 1, 0, 0,
  0, 0, 0, 0,
  0, 0, 0, 0,

  1, 1, 0, 0,
  1, 1, 0, 0,
  0, 0, 0, 0,
  0, 0, 0, 0,

  1, 1, 0, 0,
  1, 1, 0, 0,
  0, 0, 0, 0,
  0, 0, 0, 0,
};

const byte *pieces[DIFF_PIECES + 1] = {
  empty,
  piece_S,
  piece_Z,
  piece_L,
  piece_J,
  piece_O,
  piece_T,
  piece_I,
};

// status 0 == empty spot
// status 1 == entity
// status 3 == piece locked
// status 5 == border
// any even status == overlap

void action_DefineVirtGrid(){
  // visible "walls" should be at x=2 and x=13, y=13 if you want them on LED area

  for (int i = 0; i < VIRTUAL_H; ++i) {
    virt_grid[2][i]  = {6, 5};   // colour = white, status = border
    virt_grid[13][i] = {6, 5};
  }

  for (int i = 0; i < VIRTUAL_W; ++i) {
    virt_grid[i][13] = {6, 5};
  }

  // test row inside visible area (6 is visible)
  // for (int i = 0; i < VIRTUAL_W; ++i) {
  //   virt_grid[i][6] = {3, 1};    // colour=3, status=1 (yellow for example)
  // }
}


void action_ClearVirtGrid() {
  for (int x = 0; x < VIRTUAL_W; x++) {
    for (int y = 0; y < VIRTUAL_H; y++) {
      virt_entity[x][y]      = Cell{8, 0};
      virt_entity_prev[x][y] = Cell{8, 0};
      virt_overlap[x][y]     = Cell{8, 0};
    }
  }
}


void action_FixPiece() { //fix falling piece to not be movable anymore from the entity grid to the virtual grid
  

}


// Helper function: Remove current piece from the grid
void action_RemovePieceFromGrid() {
  const byte *piece = pieces[piece_id] + (piece_rotation * PIECE_SIZE);
  
  for (int y = 0; y < PIECE_H; y++) {
    for (int x = 0; x < PIECE_W; x++) {
      if (piece[y * PIECE_W + x] == 1) {
        int nx = piece_x + x;
        int ny = piece_y + y;
        
        if (nx >= 0 && nx < VIRTUAL_W && ny >= 0 && ny < VIRTUAL_H) {
          // Clear this cell (set to black/empty)
          virt_entity[nx][ny] = Cell{8, 0};
        }
      }
    }
  }
}

// Helper function: Add current piece to the grid
void action_AddPieceToGrid() {
  const byte *piece = pieces[piece_id] + (piece_rotation * PIECE_SIZE);
  
  for (int y = 0; y < PIECE_H; y++) {
    for (int x = 0; x < PIECE_W; x++) {
      if (piece[y * PIECE_W + x] == 1) {
        int nx = piece_x + x;
        int ny = piece_y + y;
        
        if (nx >= 0 && nx < VIRTUAL_W && ny >= 0 && ny < VIRTUAL_H) {
          // Set the color and status
          virt_entity[nx][ny] = Cell{(uint8_t)piece_colour, 1};
        }
      }
    }
  }
}


// =====================================================
//                   IF Functions
// =====================================================



bool if_VerticalCollision(int new_x, int new_y, int new_rotation) {
  const byte *piece = pieces[piece_id] + (new_rotation * PIECE_SIZE);

  for (int y = 0; y < PIECE_H; y++) {
    for (int x = 0; x < PIECE_W; x++) {
      if (piece[y * PIECE_W + x] != 1) continue;

      int nx = new_x + x;
      int ny = new_y + y;

      // outside virtual grid -> collision
      if (nx < 0 || nx >= VIRTUAL_W || ny < 0 || ny >= VIRTUAL_H) return true;

      // collides with borders or locked blocks in virt_grid
      if (virt_grid[nx][ny].second != 0) return true;
    }
  }
  return false;
}


// =====================================================
//                   ACTION Functions
// =====================================================

void action_GravityOnPiece() {
  // save previous entity grid
  for (int x = 0; x < VIRTUAL_W; x++) {
    for (int y = 0; y < VIRTUAL_H; y++) {
      virt_entity_prev[x][y] = virt_entity[x][y];
    }
  }

  // remove current piece from entity
  action_RemovePieceFromGrid();

  // test move down
  if (if_VerticalCollision(piece_x, piece_y + 1, piece_rotation)) {
    // restore previous entity state
    for (int x = 0; x < VIRTUAL_W; x++) {
      for (int y = 0; y < VIRTUAL_H; y++) {
        virt_entity[x][y] = virt_entity_prev[x][y];
      }
    }
    action_LockPiece();
  } else {
    piece_y++;
    action_AddPieceToGrid();
  }
}


void action_LockPiece() {
  for (int x = 0; x < VIRTUAL_W; x++) {
    for (int y = 0; y < VIRTUAL_H; y++) {
      if (virt_entity[x][y].second != 0) {
        virt_grid[x][y] = virt_entity[x][y];   // copy color
        virt_grid[x][y].second = 3;            // locked
        virt_entity[x][y] = Cell{8, 0};        // clear entity cell
      }
    }
  }
}

void clearEntity() {
  for (int x = 0; x < VIRTUAL_W; x++) {
    for (int y = 0; y < VIRTUAL_H; y++) {
      virt_entity[x][y] = Cell{8, 0};
    }
  }
}

void action_SpawnPiece() {
  clearEntity();

  piece_colour = random(0, 8);
  piece_id = random(1, DIFF_PIECES + 1);

  piece_x = 6;
  piece_y = 3;           // better: spawn near top of visible area
  piece_rotation = 0;

  action_AddPieceToGrid();

  Serial.print("Spawned piece ID: ");
  Serial.print(piece_id);
  Serial.print(" at (");
  Serial.print(piece_x);
  Serial.print(",");
  Serial.print(piece_y);
  Serial.print(") color: ");
  Serial.println(piece_colour);   // <-- you were missing println
}


// ---------------- GRID ----------------


int xyToIndex(int x, int y) {
  if (x < 0 || x >= W || y < 0 || y >= H) return -1;

  int rowFromBottom = (H - 1) - y;
  int base = rowFromBottom * W;

  if (rowFromBottom % 2 == 0)
    return base + x;
  else
    return base + (W - 1 - x);
}

void action_DrawToLED() {
  FastLED.clear(); // <--- important: wipes previous LED frame
  
  for (int ry = 0; ry < H; ry++) {        // real y: 0..9
    for (int rx = 0; rx < W; rx++) {      // real x: 0..9

      int vx = rx + CROP;                 // virtual x: 3..12
      int vy = ry + CROP;                 // virtual y: 3..12

      int idx = xyToIndex(rx, ry);

      // Draw grid layer if active
      if (virt_grid[vx][vy].second != 0) {
        leds[idx] = COLORS[(int)virt_grid[vx][vy].first];
      }

      // Draw entity layer if active (overwrites if overlapping)
      if (virt_entity[vx][vy].second != 0) {
        leds[idx] = COLORS[(int)virt_entity[vx][vy].first];
      }
    }
  }

  FastLED.show();
}

// ---------------- DRAW FUNCTION ----------------
void drawPixel(int x, int y, int colour) {
  if (colour < 0 || colour > 8) return;

  int idx = xyToIndex(x, y);
  if (idx < 0) return;

  leds[idx] = COLORS[colour];
  FastLED.show();
}

// ---------------- COMMAND READER ----------------
void ReadCommands() {
  static String line = "";

  while (Serial.available()) {
    char c = Serial.read();

    if (c == '\r') continue;

    if (c == '\n') {
      line.trim();

      // Expect format: drawPixel(x,y,c)
      if (line.startsWith("drawPixel")) {
        int x,y,c;

        if (sscanf(line.c_str(), "drawPixel(%d,%d,%d)", &x, &y, &c) == 3) {
          drawPixel(x,y,c);
          Serial.println("OK");
        } else {
          Serial.println("Format error");
        }
      }
      // New command to spawn a piece
      else if (line.startsWith("spawnPiece")) {
        action_SpawnPiece();
        Serial.println("Piece spawned");
      }

      line = "";
    }
    else {
      line += c;
    }
  }
}

// ---------------- SETUP / LOOP ----------------
void setup() {
  Serial.begin(115200);
  FastLED.addLeds<LED_TYPE, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS);
  FastLED.setBrightness(BRIGHTNESS);
  FastLED.clear(true);

  action_ClearVirtGrid();
  action_DefineVirtGrid();
  
  // Optional: spawn a piece at startup for testing
  action_SpawnPiece();
  action_DrawToLED();
}

void loop() {
  action_GravityOnPiece();
  action_DrawToLED();
  ReadCommands();
  delay(1000);
}


/* void loop() {
  action_Start();
  while(!if_GameEnd()){
    for(int i = 0; i < 30; ++i) {
    // check for User Input
    if(!if_HorizontalColision() && !if_VerticalCollision*()) {
       // Execute User Input
      else
        delay(33);
    } 
    action_GravityOnPiece();
  }
  action_GameEnd();
} */
